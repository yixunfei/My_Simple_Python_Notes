
# NumPy

`NumPy` 是 Python 中用于科学计算的基础库，它提供了高效的多维数组对象以及用于数学和逻辑运算的函数集合。
`Pandas` 实际上是基于 `NumPy` 构建的，因此 `NumPy` 常常与 `Pandas` 配合使用。

## 安装导入

```Bash
import numpy as np
```


## 创建数组


### 从列表创建数组

```python
arr = np.array([1, 2, 3, 4])
```
### 从文件加载数据

```python
loaded_arr = np.load('data.npy')
```

### 创建多维数组

```python
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
```

## 常用操作

### 数组属性

#### 查看数组形状

```python
shape = arr_2d.shape
```

#### 查看数组维度

```python
ndim = arr_2d.ndim
```

#### 查看数组元素类型

```python
dtype = arr_2d.dtype
```

### 数组操作

#### 数组切片

```python
slice_arr = arr_2d[0, 1]
```

#### 数组转置

```python
transposed = arr_2d.T
```

#### 数组重塑

```python
reshaped = arr_2d.reshape(3, 2)
```

### 数组初始化

#### 创建全零数组

```python
zeros_arr = np.zeros((3, 4))
```

#### 创建全一数组

```python
ones_arr = np.ones((3, 4))
```

#### 创建常数数组

```python
const_arr = np.full((3, 4), 7)
```

#### 创建单位矩阵

```python
identity_arr = np.eye(3)
```

#### 创建随机数组

```python
random_arr = np.random.rand(3, 4)
```

#### 创建指定范围内的随机整数数组

```python
randint_arr = np.random.randint(0, 10, size=(3, 4))
```

### 数学运算

#### 数组加法

```python
result = arr + arr
```

#### 数组乘法

```python
result = arr * arr
```

#### 点积

```python
dot_product = np.dot(arr_2d, arr_2d.T)
```

#### 幂运算

```python
power_result = np.power(arr, 2)
```

#### 平方根

```python
sqrt_result = np.sqrt(arr)
```

#### 指数运算

```python
exp_result = np.exp(arr)
```

#### 对数运算

```python
log_result = np.log(arr[arr > 0])
```

### 统计函数

#### 求和

```python
total_sum = np.sum(arr)
```

#### 最大值

```python
max_value = np.max(arr)
```

#### 最小值

```python
min_value = np.min(arr)
```

#### 平均值

```python
average = np.mean(arr)
```

#### 标准差

```python
std_dev = np.std(arr)
```

#### 方差

```python
variance = np.var(arr)
```

### 索引和切片

#### 选择特定元素

```python
element = arr_2d[0, 1]
```

#### 切片

```python
slice_arr = arr_2d[0:2, 1:3]
```

### 条件选择

#### 使用布尔索引

```python
filtered_arr = arr[arr > 2]
```
### 广播机制

#### 广播相加
```python
broadcasted_result = arr + np.array([1])
```

### 数组连接

#### 水平连接

```python
h_concat = np.hstack((arr, arr))
```

#### 垂直连接

```python
v_concat = np.vstack((arr, arr))
```

### 数组分割

#### 水平分割

```python
h_split = np.hsplit(arr_2d, 2)
```

#### 垂直分割

```python
v_split = np.vsplit(arr_2d, 2)
```

### 索引和掩码

#### 使用掩码

```python
mask = arr > 2
masked_arr = arr[mask]
```

### 矩阵操作

#### 矩阵逆

```python
inverse = np.linalg.inv(arr_2d)
```

#### 矩阵秩

```python
rank = np.linalg.matrix_rank(arr_2d)
```

#### 矩阵求解

```python
solution = np.linalg.solve(arr_2d, np.array([1, 2, 3]))
```

#### 矩阵乘法

```python
matrix_product = np.dot(matrix1, matrix2)
```

#### 矩阵的行列式

```python
determinant = np.linalg.det(matrix)
```


### 复数操作

#### 创建复数数组

```python
complex_arr = np.array([1+2j, 3+4j])
```

#### 实部

```python
real_part = np.real(complex_arr)
```

#### 虚部

```python
imag_part = np.imag(complex_arr)
```

#### 共轭

```python
conjugate = np.conjugate(complex_arr)
```

### 复杂数操作

#### 幅度（模）

```python
magnitude = np.abs(complex_arr)
```

#### 相位角

```python
angle = np.angle(complex_arr)
```

#### 复数乘法

```python
complex_product = complex_arr * complex_arr
```

### 特殊函数

#### 正弦函数

```python
sin_values = np.sin(arr)
```

#### 余弦函数

```python
cos_values = np.cos(arr)
```

#### 正切函数

```python
tan_values = np.tan(arr)
```

#### 反正弦函数

```python
arcsin_values = np.arcsin(arr)
```

#### 反余弦函数

```python
arccos_values = np.arccos(arr)
```

#### 反正切函数

```python
arctan_values = np.arctan(arr)
```

### 线性代数

#### 特征值和特征向量

```python
eigenvalues, eigenvectors = np.linalg.eig(arr_2d)
```

#### 奇异值分解

```python
U, s, Vt = np.linalg.svd(arr_2d)
```

#### 矩阵的迹

```python
trace = np.trace(arr_2d)
```
### 数组排序

#### 升序排序

```python
sorted_arr = np.sort(arr)
```

#### 降序排序

```python
sorted_desc_arr = np.sort(arr)[::-1]
```

### 数组的唯一值和计数

#### 获取唯一值

```python
unique_values = np.unique(arr)
```

#### 获取唯一值及其计数

```python
unique_values, counts = np.unique(arr, return_counts=True)
```

### 数组的拼接和分割

#### 沿着新轴拼接

```python
stacked_arr = np.stack((arr, arr), axis=-1)
```

#### 沿着现有轴拼接

```python
concatenated_arr = np.concatenate((arr, arr), axis=0)
```

#### 沿着第一轴分割

```python
split_arr = np.split(arr, 2, axis=0)
```

### 数组的索引和选择

#### 高阶索引

```python
indices = [1, 3]
selected_elements = arr[indices]
```

#### 布尔索引

```python
mask = arr > 2
selected_elements = arr[mask]
```

### 数组的填充和裁剪

#### 填充边界

```python
padded_arr = np.pad(arr, pad_width=1, mode='constant', constant_values=0)
```

#### 裁剪数组

```python
trimmed_arr = arr[1:-1, 1:-1]
```

### 数组的滚动和循环移位

#### 滚动数组

```python
rolled_arr = np.roll(arr, shift=1)
```

#### 循环移位

```python
cyclic_shifted_arr = np.roll(arr, shift=-1)
```


### 数组的比较和逻辑操作

#### 元素级别的比较

```python
comparison = arr > 2
```

#### 逻辑与

```python
logical_and = np.logical_and(arr > 2, arr < 5)
```

#### 逻辑或

```python
logical_or = np.logical_or(arr > 2, arr < 5)
```

#### 逻辑非

```python
logical_not = np.logical_not(arr > 2)
```

### 数组的类型转换

#### 转换为整型

```python
int_arr = arr.astype(int)
```

#### 转换为浮点型

```python
float_arr = arr.astype(float)
```

#### 转换为复数型

```python
complex_arr = arr.astype(complex)
```

### 数组的视图和拷贝

#### 创建视图

```python
view_arr = arr.view()
```

#### 创建拷贝

```python
copy_arr = arr.copy()
```

### 数组的迭代

####  `nditer` 迭代器

```python
for element in np.nditer(arr):
    print(element)
```

### 数组的广播

```python
result = arr + np.array([1, 2])
```

### 数组的通用函数（ufunc）

#### 幂运算

```python
power_result = np.power(arr, 2)
```

#### 开方

```python
sqrt_salaries = np.sqrt(data['salary'])
```

#### 指数函数

```python
exp_salaries = np.exp(data['salary'])
```

#### 最大值

```python
max_result = np.maximum(arr, 10)
```

#### 最小值

```python
min_result = np.minimum(arr, 5)
```

### 保存数组到文件

```python
np.save('data.npy', arr)
```

### 数组的性能优化

#### 使用矢量化操作代替循环

```python
result = arr * 2  # 更快比使用循环
```

#### 使用内建的 NumPy 函数

```python
result = np.sum(arr)  # 比使用 Python 内置 sum 更快
```

#### 使用 `numba` 加速计算

```python
@numba.jit
def my_function(arr):
    return arr * 2
```

### 数组的随机数生成

#### 随机种子

```python
np.random.seed(0)
```

#### 随机整数

```python
random_integers = np.random.randint(0, 10, size=(3, 4))
```

#### 随机浮点数

```python
random_floats = np.random.rand(3, 4)
```

#### 正态分布随机数

```python
normal_randoms = np.random.normal(loc=0.0, scale=1.0, size=(3, 4))
```

### 数组的类型和结构

#### 创建结构化数组

```python
structured_arr = np.array([(1, 2), (3, 4)], dtype=[('a', int), ('b', float)])
```

#### 访问结构化数组字段

```python
field_a = structured_arr['a']
```

#### 定义复杂数据类型

```python
dtype = np.dtype([('name', 'S10'), ('age', 'i4'), ('salary', 'f8')])
```

### 数组的图形表示

#### 使用 `matplotlib` 绘制数组

```python
import matplotlib.pyplot as plt
plt.plot(arr)
plt.show()
```

### 数组的稀疏表示

使用 `scipy.sparse` 创建稀疏矩阵

```python
from scipy.sparse import csr_matrix
sparse_matrix = csr_matrix((data, (row, col)), shape=(4, 5))
```

### 数组的高级数学函数

#### 特殊函数

```python
gamma_values = scipy.special.gamma(arr)
```

#### 信号处理函数

```python
from scipy.signal import convolve
filtered = convolve(arr, kernel)
```

### 数组的傅立叶变换

#### 快速傅立叶变换

```python
fft_result = np.fft.fft(arr)
```

#### 逆快速傅立叶变换

```python
ifft_result = np.fft.ifft(fft_result)
```

### 卷积

#### 一维数组卷积

```python
numpy.convolve(a, v, mode='full')
```
#### 高维度的数组卷积

```python
scipy.signal.convolve(in1, in2, mode='full', method='auto')
```

### 性能分析

```python
%timeit result = arr * 2
```

### 调试和验证

```python
assert np.allclose(result1, result2)
```


示例

```python
import numpy as np

def gaussian(x, mu, sigma):
    return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mu) / sigma)**2)

# 使用示例
x = np.linspace(-3, 3, 100)
mu = 0
sigma = 1
y = gaussian(x, mu, sigma)

# 可视化高斯函数
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.title('Gaussian Function')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid(True)
plt.show()

```

```python
import numpy as np

def gaussian(x, mu, sigma):
    return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mu) / sigma)**2)

# 使用示例
x = np.linspace(-3, 3, 100)
mu = 0
sigma = 1
y = gaussian(x, mu, sigma)

# 可视化高斯函数
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.title('Gaussian Function')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid(True)
plt.show()
```

```python
import numpy as np

# 定义状态空间
states = ['A', 'B', 'C']

# 创建状态转移矩阵
transition_matrix = np.array([
    [0.7, 0.2, 0.1],  # P(A->A) = 0.7, P(A->B) = 0.2, P(A->C) = 0.1
    [0.3, 0.5, 0.2],  # P(B->A) = 0.3, P(B->B) = 0.5, P(B->C) = 0.2
    [0.2, 0.3, 0.5]   # P(C->A) = 0.2, P(C->B) = 0.3, P(C->C) = 0.5
])

# 检查状态转移矩阵的每一行是否和为1
assert np.allclose(np.sum(transition_matrix, axis=1), 1)

# 生成马尔科夫链的序列
current_state = np.random.choice(states)
sequence = [current_state]

for _ in range(10):  # 生成10步的序列
    next_state_index = np.random.choice(len(states), p=transition_matrix[states.index(current_state)])
    current_state = states[next_state_index]
    sequence.append(current_state)

print(sequence)
```



```python
import numpy as np

# 定义状态空间和观测空间
states = ['Rainy', 'Sunny']
observations = ['Walk', 'Shop', 'Clean']

# 状态转移矩阵
transition_matrix = np.array([
    [0.7, 0.3],  # P(Rainy->Rainy) = 0.7, P(Rainy->Sunny) = 0.3
    [0.4, 0.6]   # P(Sunny->Rainy) = 0.4, P(Sunny->Sunny) = 0.6
])

# 观测概率矩阵
observation_matrix = np.array([
    [0.1, 0.4, 0.5],  # P(Walk|Rainy) = 0.1, P(Shop|Rainy) = 0.4, P(Clean|Rainy) = 0.5
    [0.6, 0.3, 0.1]   # P(Walk|Sunny) = 0.6, P(Shop|Sunny) = 0.3, P(Clean|Sunny) = 0.1
])

# 初始状态概率向量
initial_state_probabilities = np.array([0.6, 0.4])  # P(Rainy) = 0.6, P(Sunny) = 0.4

# 生成HMM的观测序列
current_state = np.random.choice(states, p=initial_state_probabilities)
observation_sequence = []

for _ in range(10):  # 生成10个观测
    observation = np.random.choice(observations, p=observation_matrix[states.index(current_state)])
    observation_sequence.append(observation)
    
    # 更新状态
    next_state_index = np.random.choice(len(states), p=transition_matrix[states.index(current_state)])
    current_state = states[next_state_index]

print(observation_sequence)
```


```python
import numpy as np
from scipy.stats import norm, gamma

# 数据
data = np.random.randn(100)  # 假设数据来自标准正态分布

# 先验参数
alpha_0 = 1.0  # 伽玛分布的形状参数
beta_0 = 1.0   # 伽玛分布的尺度参数
mu_0 = 0.0     # 均值的先验均值
lambda_0 = 1.0 # 均值的先验精度（1/方差）

# 变分参数初始化
q_alpha = alpha_0
q_beta = beta_0
q_mu = mu_0
q_lambda = lambda_0

# ELBO 计算函数
def elbo(q_alpha, q_beta, q_mu, q_lambda):
    # 似然项
    log_likelihood = np.sum(norm.logpdf(data, loc=q_mu, scale=np.sqrt(1/q_lambda)))
    # KL散度项
    kl_divergence = (gamma.logpdf(q_alpha, alpha_0, scale=1/beta_0) 
                     + norm.logpdf(q_mu, mu_0, scale=np.sqrt(1/q_lambda)) 
                     - gamma.logpdf(q_alpha, q_alpha, scale=1/q_beta)
                     - norm.logpdf(q_mu, q_mu, scale=np.sqrt(1/q_lambda)))
    return log_likelihood + kl_divergence

# 优化变分参数
learning_rate = 0.01
for i in range(1000):
    # 梯度下降更新
    grad_q_alpha = ...
    grad_q_beta = ...
    grad_q_mu = ...
    grad_q_lambda = ...
    
    q_alpha += learning_rate * grad_q_alpha
    q_beta += learning_rate * grad_q_beta
    q_mu += learning_rate * grad_q_mu
    q_lambda += learning_rate * grad_q_lambda
    
    if i % 100 == 0:
        print(f"Iteration {i}: ELBO = {elbo(q_alpha, q_beta, q_mu, q_lambda)}")

# 最终变分参数
print("Final variational parameters:")
print(f"q_alpha: {q_alpha}")
print(f"q_beta: {q_beta}")
print(f"q_mu: {q_mu}")
print(f"q_lambda: {q_lambda}")

```


# `Pandas`

`Pandas` 是一个非常流行的数据分析库，提供了 `DataFrame` 和 `Series` 数据结构，非常适合进行数据清洗、处理和分析。
它能够处理多种数据源，如 CSV、Excel、SQL 数据库，并提供了大量的数据操作函数，如合并、重塑、选择、过滤等。

## 安装导入

```python
import pandas as pd
```

## 基础操作

### 创建 DataFrame

```python
data = {'Name': ['zhangsan', 'lisi', 'wanger', 'xiaoming'],
        'Age': [20, 21, 19, 20],
        'Score': [85, 80, 90, 85]}
df = pd.DataFrame(data)
print(df)
```

### 读取 CSV 文件

```python
df = pd.read_csv('data.csv')
```

### 查看前几行数据

```python
print(df.head())  # 默认显示前5行
print(df.head(3))  # 显示前3行
```

### 查看后几行数据

```python
print(df.tail())  # 默认显示最后5行
print(df.tail(3))  # 显示最后3行
```

### 获取数据信息

```python
print(df.info())
```

### 描述性统计

```python
print(df.describe())
```

### 访问单列

```python
print(df['Name'])
```

### 访问多列

```python
print(df[['Name', 'Age']])
```

### 行筛选

```python
print(df[df['Age'] > 20])
```

### 列筛选

```python
print(df.loc[:, ['Name', 'Score']])
```


### 按条件筛选

```python
print(df[(df['Age'] > 20) & (df['Score'] > 80)])
```

### 添加列

```python
df['Grade'] = df['Score'].apply(lambda x: 'A' if x >= 90 else 'B')
```

### 删除列

```python
df = df.drop('Grade', axis=1)
```


### 重命名列

```python
df = df.rename(columns={'Score': 'Test Score'})
```


### 缺失值处理

```python
df = df.fillna(0)
```

### 排序

```python
df = df.sort_values(by='Age', ascending=False)
```

### 分组

```python
grouped = df.groupby('Name').mean()
```

### 合并数据

```python
df1 = pd.DataFrame({'Name': ['xiaoming', 'zhangsan'], 'Age': [22, 20]})
df2 = pd.DataFrame({'Name': ['xiaoming', '；lisi'], 'Salary': [50000, 60000]})
result = pd.merge(df1, df2, on='Name')
```

### 数据透视表

```python
pivot_table = df.pivot_table(values='Score', index='Name', columns='Age', aggfunc='mean')
```

### 聚合函数

```python
result = df.agg({'Age': ['min', 'max'], 'Score': ['mean', 'sum']})
```

### 数据重塑

```python
melted = pd.melt(frame=df, id_vars=['Name'], value_vars=['Age', 'Score'])
```

### 保存数据到 CSV

```python
df.to_csv('output.csv', index=False)
```

### 数据类型转换

```python
df['Age'] = df['Age'].astype(int)
```


### 字符串操作

```python
df['Name'] = df['Name'].str.upper()
```

### 时间序列操作

```python
df['Date'] = pd.to_datetime(df['Date'])
```

### 重复值处理

```python
df = df.drop_duplicates(subset=['Name'])
```

### 数据类型检查

```python
print(df.dtypes)
```

### 计算频率

```python
freq = df['Name'].value_counts()
```

### 应用函数

```python
df['NewColumn'] = df['Age'].apply(lambda x: x + 10)
```


### 索引操作

#### 设置索引

```python
  df.set_index('Name', inplace=True)
```

#### 重置索引

```python
  df.reset_index(inplace=True)
```

### 条件赋值

```python
df.loc[df['Age'] > 20, 'AgeGroup'] = 'Adult'
df.loc[df['Age'] <= 20, 'AgeGroup'] = 'Teenager'
```

### 空值处理

#### 检测空值

```python
  print(df.isnull().sum())
```

#### 删除含有空值的行

```python
  df = df.dropna()
```

#### 填充空值

```python
  df = df.fillna(method='ffill')  # 前向填充
  df = df.fillna(method='bfill')  # 后向填充
  df = df.fillna(df.mean())       # 使用平均值填充
```

### 时间序列操作

#### 按日期排序

```python
  df = df.sort_values('Date')
```

#### 按月/年/日聚合数据

```python
  df.resample('M', on='Date')['Score'].mean()
```

### 多级索引

#### 创建多级索引

```python
  df = df.set_index(['Name', 'Age'])
```

#### 层次化索引操作

```python
  df.xs('xiaoming', level='Name')  # 选取特定层级上的数据
```

### 高级筛选

```python
df.loc[(df['Age'] > 20) & (df['Name'] == 'xiaoming'), ['Score']]
```

### 矩阵运算

```python
import numpy as np
df['Total'] = np.dot(df[['Age', 'Score']], [1, 2])
```

### 索引切片

```python
df.loc['zhangsan':'xiaoming', 'Age':'Score']
```

### 时间窗口函数

```python
df['RollingMean'] = df['Score'].rolling(window=2).mean()
```
### 数据类型转换

```python
df['Age'] = df['Age'].astype(str)
```

### 字典映射

```python
grade_map = {85: 'A', 80: 'B', 90: 'A'}
df['Grade'] = df['Score'].map(grade_map)
```

### 数据标准化

```python
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
df['Age'] = scaler.fit_transform(df[['Age']])
```

### 数据导出到 Excel

```python
df.to_excel('output.xlsx', sheet_name='Sheet1')
```

### 数据导入从 SQL

```python
import sqlite3
conn = sqlite3.connect('example.db')
df = pd.read_sql_query("SELECT * FROM table_name", conn)
```

### 数据导出到 SQL

```python
df.to_sql('table_name', conn, if_exists='append', index=False)
```

### 时间序列滞后与移动

```python
df['Lag1'] = df['Score'].shift(1)
df['RollingSum'] = df['Score'].rolling(window=3).sum()
```

### 索引重置

```python
df = df.reset_index(drop=True)
```

### 字符串分割

```python
df[['FirstName', 'LastName']] = df['Full Name'].str.split(' ', expand=True)
```

### 多条件排序

```python
df = df.sort_values(by=['Age', 'Score'], ascending=[False, True])
```

### 多个条件的统计汇总

```python
grouped = df.groupby(['AgeGroup', 'Name']).agg({'Score': ['mean', 'count']})
```

### 交叉表分析

```python
pd.crosstab(index=df['AgeGroup'], columns=df['Name'])
```

### 时间序列的周期性分析

```python
df['Month'] = df['Timestamp'].dt.month
df['Year'] = df['Timestamp'].dt.year
```

### 数据透视表的复杂使用

```python
pivot = pd.pivot_table(df, values='Score', index=['Name'], columns=['AgeGroup'], aggfunc=np.sum, fill_value=0)
```

### 数据采样

```python
sample_df = df.sample(frac=0.5, random_state=42)
```

### 数据拆分

```python
train, test = train_test_split(df, test_size=0.2, random_state=42)
```

### 时间序列的差分

```python
df['Diff'] = df['Score'].diff()
```

### 数据的指数加权移动平均

```python
df['EWMA'] = df['Score'].ewm(span=2).mean()
```

### 数据的累积和

```python
df['CumulativeSum'] = df['Score'].cumsum()
```

### 数据的累积产品

```python
df['CumulativeProduct'] = df['Score'].cumprod()
```

### 数据的累积最大值

```python
df['CumulativeMax'] = df['Score'].cummax()
```

### 数据的累积最小值

```python
df['CumulativeMin'] = df['Score'].cummin()
```

### 数据的排名

```python
df['Rank'] = df['Score'].rank()
```

### 数据的百分位数

```python
percentile_25 = df['Score'].quantile(0.25)
```


### 数据的中位数

```python
median_score = df['Score'].median()
```

### 数据的众数

```python
mode_score = df['Score'].mode()
```

### 数据的方差

```python
variance_score = df['Score'].var()
```

### 数据的标准差

```python
std_dev_score = df['Score'].std()
```

### 数据的偏度

```python
skewness_score = df['Score'].skew()
```

### 数据的峰度

```python
kurtosis_score = df['Score'].kurt()
```

### 数据的自相关

```python
autocorrelation = df['Score'].autocorr(lag=1)
```

### 数据的卷积

```python
convolution = np.convolve(df['Score'], [0.5, 0.5], mode='same')
```

### 数据的傅里叶变换

```python
fourier_transform = np.fft.fft(df['Score'])
```

### 数据的逆傅里叶变换

```python
inverse_fourier_transform = np.fft.ifft(fourier_transform)
```

### 数据的离散余弦变换

```python
dct = scipy.fftpack.dct(df['Score'])
```

### 数据的离散小波变换

```python
coeffs = pywt.wavedec(df['Score'], 'db1')
```

### 数据的Z-score标准化

```python
df['Score'] = (df['Score'] - df['Score'].mean()) / df['Score'].std()
```

### 数据的Min-Max缩放

```python
df['Score'] = (df['Score'] - df['Score'].min()) / (df['Score'].max() - df['Score'].min())
```

### 数据的Log变换

```python
df['Score'] = np.log(df['Score'] + 1)
```



### 数据的图分析

#### 箱线图

```python
import matplotlib.pyplot as plt
df.boxplot(column='Score')
plt.show()
```


#### 直方图分析

```python
df['Score'].hist(bins=10)
plt.show()
```


#### 相关性矩阵

```python
corr_matrix = df.corr()
```

#### 相关性矩阵的热力图

```python
import seaborn as sns
sns.heatmap(corr_matrix, annot=True)
plt.show()
```

#### 散点图

```python
df.plot.scatter(x='Age', y='Score')
plt.show()
```

#### 时间序列图

```python
df.plot.line(x='Timestamp', y='Score')
plt.show()
```

#### 饼图

```python
df['Name'].value_counts().plot.pie(autopct='%1.1f%%')
plt.show()
```

#### 条形图

```python
df['Name'].value_counts().plot.bar()
plt.show()
```

#### 堆叠条形图

```python
df.groupby(['AgeGroup', 'Name'])['Score'].sum().unstack().plot.bar(stacked=True)
plt.show()
```

#### 面积图

```python
df.plot.area(y=['Score', 'Age'])
plt.show()
```

#### KDE图

```python
sns.kdeplot(df['Score'])
plt.show()
```

#### 六边形分布图

```python
df.plot.hexbin(x='Age', y='Score', gridsize=20)
plt.show()
```

#### 并排箱线图

```python
df.boxplot(column='Score', by='AgeGroup')
plt.show()
```

#### 子图布局

```python
fig, axes = plt.subplots(nrows=2, ncols=1)
df.plot.scatter(x='Age', y='Score', ax=axes[0])
df['Score'].hist(ax=axes[1])
plt.show()
```

#### 多重图

```python
df.plot.scatter(x='Age', y='Score', c='Score', colormap='viridis')
plt.colorbar()
plt.show()
```

#### 误差线图

```python
df.plot.errorbar(x='Age', y='Score', yerr=df['Score'].std(), fmt='o')
plt.show()
```

#### 累积分布函数图

```python
df['Score'].plot.hist(cumulative=True, density=True)
plt.show()
```

#### QQ图

```python
from statsmodels.graphics.gofplots import qqplot
qqplot(df['Score'], line='s')
plt.show()
```

#### 帕累托图

```python
df['Name'].value_counts().sort_values(ascending=False).plot.bar()
plt.axvline(x=len(df['Name'].value_counts())*0.2, color='r', linestyle='--')
plt.show()
```

#### 运行图

```python
df['Score'].plot()
plt.show()
```
# Matplotlib

TODO....

# Seaborn


# SciPy


# Scikit-Learn


# Statsmodels